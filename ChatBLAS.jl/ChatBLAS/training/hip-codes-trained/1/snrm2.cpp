#include "chatblas_hip.h" 

__global__ void snrm2_kernel(int n, float *x, float *res) { int index = threadIdx.x + blockIdx.x * blockDim.x; extern __shared__ float sum[]; sum[index] = 0.0; if (index < n) { sum[index] = x[index] * x[index]; } __syncthreads(); for (int i = blockDim.x / 2; i > 0; i >>= 1) { if (index < i) { sum[index] += sum[index + i]; } __syncthreads(); } if (index == 0) { *res = sqrtf(sum[0]); } } 

float chatblas_snrm2(int n, float *x) { float *x_device; float *result_device; float result; float *partial_res; const int threads_per_block = 256; const int blocks_per_grid = (n + threads_per_block - 1) / threads_per_block; partial_res = (float*) malloc(blocks_per_grid * sizeof(float)); hipMalloc((void**)&x_device, n * sizeof(float)); hipMalloc((void**)&result_device, 1 * sizeof(float)); hipMemcpy(x_device, x, n * sizeof(float), hipMemcpyHostToDevice); snrm2_kernel<<<blocks_per_grid, threads_per_block>>>(n, x_device, result_device); hipMemcpy(partial_res, result_device, blocks_per_grid * sizeof(float), hipMemcpyDeviceToHost); result = 0.0; for (int i = 0; i < blocks_per_grid; ++i) { result += partial_res[i]; } result = sqrtf(result); hipFree(x_device); hipFree(result_device); free(partial_res); return result; }
